# Tree-sitter Integration Architecture (2025)

## Overview

ScopeMux uses Tree-sitter for high-performance, incremental parsing. The architecture is designed to produce two distinct tree structures from source code: a Concrete Syntax Tree (CST) for full-fidelity representation and an Abstract Syntax Tree (AST) for semantic analysis.

The entire parsing process is managed through a central `ParserContext` struct, which holds the state, configuration, and results of a parsing operation. The public API for all parsing activities is exposed through `core/include/scopemux/parser.h`.

## Core Components

The parsing system is composed of several key components:

### 1. Public API and Data Structures (`parser.h`)

This header file is the primary entry point for the parsing system. It defines:
- **`ParserContext`**: A central struct that holds the parser state, including the source code, language, mode (AST/CST), and the resulting syntax trees.
- **`ASTNode` & `CSTNode`**: The core data structures for the abstract and concrete syntax trees.
- **Public Functions**: Core functions like `parser_init`, `parser_parse_string`, and functions to access the resulting AST/CST.

### 2. Parser Orchestration (`parser.c`)

This file is the engine of the parsing system. It is responsible for:
- Managing the lifecycle of the `ParserContext`.
- Handling file I/O and reading source code.
- Detecting the programming language.
- Orchestrating the parsing process by calling the Tree-sitter integration layer.

### 3. Tree-sitter Integration Facade (`tree_sitter_integration.c`)

This file acts as a high-level bridge to the underlying Tree-sitter library. It provides facade functions that delegate to more specialized, internal modules for complex tasks:
- `ts_tree_to_ast()`: Converts a Tree-sitter tree into ScopeMux's language-agnostic AST.
- `ts_tree_to_cst()`: Converts a Tree-sitter tree into a detailed CST.

### 4. Query Manager (`query_manager.c`)

Responsible for managing Tree-sitter queries (`.scm` files), which are used to extract semantic information for the AST. Its tasks include:
- Loading `.scm` files from disk.
- Compiling queries for a specific language.
- Caching compiled queries for performance.

## Dual-Mode Parsing

ScopeMux supports two parsing modes, which can be configured in the `ParserContext`:

#### CST Mode (Concrete Syntax Tree)
- **Purpose**: To preserve the complete syntactic structure of the source code, including every token, punctuation, and whitespace.
- **Source**: Generated by `ts_tree_to_cst` through a direct traversal of the Tree-sitter parse tree.
- **Use Cases**: Source code reconstruction, code formatting, and precise source range mapping.

#### AST Mode (Abstract Syntax Tree)
- **Purpose**: To provide a simplified, semantic representation of the code, focusing on structure and meaning rather than syntax.
- **Source**: Generated by `ts_tree_to_ast` using `.scm` queries to identify and extract meaningful code constructs (functions, classes, etc.).
- **Use Cases**: Powering InfoBlocks, generating Symbol IR, building call graphs, and enabling semantic analysis and refactoring tools.

## Query-Driven AST Generation

The AST is built by executing a series of semantic queries against the Tree-sitter parse tree. This process is highly extensible:

1.  The `parser.c` orchestrator invokes `ts_tree_to_ast`.
2.  This function, via the `QueryManager`, loads and executes a sequence of `.scm` queries for the target language.
3.  Each query match corresponds to a semantic element (e.g., a function definition, a class).
4.  An `ASTNode` is created for each match and added to the tree, forming a hierarchical, semantic representation of the code.

### Mapping Query Types to ASTNodeType
- Semantic query types (e.g., "functions", "classes") captured by Tree-sitter queries are mapped to `ASTNodeType` enums **directly in C code**.
- This mapping is implemented in `core/src/config/node_type_mapping_loader.c` via the function `get_node_type_for_query(const char *query_type)`.
- There is **no config file or JSON**; all mappings are hardcoded for reliability and reproducibility.
- To add a new mapping, simply update the mapping logic in the loader source and recompile.

Conceptually, queries are often ordered to build the tree logically, for example:
1.  `classes.scm` / `structs.scm` to establish container scopes.
2.  `functions.scm` / `methods.scm` to define callable units.
3.  `variables.scm` and `imports.scm` for declarations.

### Query Directory Structure

Queries are organized by language in the `queries/` directory, allowing for easy extension and maintenance:
```
queries/
├── c/
├── cpp/
│   ├── classes.scm
│   ├── functions.scm
│   └── ...
├── python/
└── ... other languages
```

## Extending the System

### Adding a New Language

1.  **Integrate Grammar**: Add the Tree-sitter grammar library for the new language to the build system.
2.  **Register Language**: Update the `QueryManager` (`query_manager.c`) and the parser's language initialization logic to recognize the new language.
3.  **Add Queries**: Create a new directory under `queries/` for the language and add `.scm` files to extract the semantic constructs you need.

### Adding New Semantic Constructs

1.  **Write a Query**: Create a new `.scm` file or update an existing one with a query that captures the desired code pattern.
2.  **Update AST Builder**: Modify the AST generation logic (within the internal implementation modules) to handle the new query captures and create the appropriate `ASTNode` types.

2. **Create Query Files**:
   - Add a language subdirectory in `queries/`
   - Create `.scm` files for each semantic construct

3. **Update Node Type Mappings**:
   - Add a new mapping for your query type in `core/src/config/node_type_mapping_loader.c` (see the function `get_node_type_for_query`).
   - Example:
     ```c
     if (strcmp(query_type, "my_new_construct") == 0)
         return NODE_MY_NEW_CONSTRUCT;
     ```
   - Recompile the project.

4. **Add Test Coverage**:
   - Create example test files in `core/tests/examples/<language>/`
   - Add language-specific test cases

### Adding New Semantic Queries

1. **Create a new `.scm` query file** for the semantic construct
2. **Add the query type mapping** in `core/src/config/node_type_mapping_loader.c` as described above
3. **Update the query execution order** in `process_all_ast_queries`
4. **Add test cases** that utilize the new semantic construct

## Best Practices

### Query Development

- Use Tree-sitter's query language documentation as a reference
- Test queries against a variety of real code examples
- Include comments in query files to explain complex patterns
- Break down large queries into focused, maintainable files

### AST Post-processing

- Apply consistent naming schemes for qualified names
- Verify parent-child relationships are established correctly
- Add richer semantic information when available
- Preserve source ranges for source mapping

### Error Handling

- Implement fallback mechanisms for query failures
- Provide detailed diagnostics for query compilation issues
- Always ensure a valid AST root even when queries fail
- Log detailed information about node counts and performance

## Performance Considerations

- Queries are cached to avoid repeated compilations
- Parse only what's needed using selective query execution
- Consider memory use for large files and deep trees
- Use incremental parsing for continuously edited files

## References

- [Tree-sitter Documentation](https://tree-sitter.github.io/tree-sitter/)
- [Tree-sitter Query Language](https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax)
