# Most Important Notes

* Do not write "you" or "your" in the code. Write comments with a standard documentation tone. In the comments, note useful information, caveats, and todo/action items. If you see commented code that do not follow this best practice, update them at the spot. Also clarify vague messages whenever possible.

* Build the python bindings with this shell script ran from the project root directory ONLY WHEN PYTHON IS INVOLVED IN THE TASK, othwerise run the language script relevant to the task instead: `build_all_and_pybind.sh `

* I am going to suggest you to fix errors in the test suite at times. Do not manually execute command strings to run the test suite unless if you are targeting a single test, even though that is not preferred. Run the tests via the shell scripts in the project root directory.

Best Practice in C
- Never forward-declare a typedef for an enum in a header unless you are also providing the full definition in the same place.
- Always include the header that defines the typedef if you want to use the typedef name in function signatures or struct fields.

Here are the shell scripts
- run_<some_programming_language>_tests.sh
- run_misc_tests.sh <- Tests basic functionality for parsing
- run_interfile_tests.sh

Example files and their JSON validation cases exist in these directories. You may have trouble accessing them because of gitignore but they do in fact exist so treat them as if the paths are absolutely valid.
(scopemux) matrillo@matrillobase1:~/apps/scopemux$ ls core/tests/examples/c/
basic_syntax  complex_structures  file1.c  file2.c  file_io  memory_management  struct_union_enum
(scopemux) matrillo@matrillobase1:~/apps/scopemux$ ls core/tests/examples/c/basic_syntax/
hello_world.c  hello_world.c.expected.json  variables_loops_conditions.c  variables_loops_conditions.c.expected.json

For tests, the examples will be located in examples/ inside of the build directory

build/core/tests/examples/*

!IMPORTANT! 

For the easiest method of debugging, run the test shell script runner once and verify contents via the .txt file of the same name.

!IMPORTANT!

# 🔍 Tree-sitter Parsing in ScopeMux

## 📚 Role of Tree-sitter

Tree-sitter provides **incremental**, **multi-language** parsing capabilities.
It outputs **Concrete Syntax Trees (CSTs)** directly from source code and supports semantic extraction via **Tree-sitter queries**.

ScopeMux now supports dual-mode parsing:

* **CSTs**: Full-fidelity syntax trees that include every token, punctuation, and structure.
* **ASTs**: Semantic, language-agnostic trees using custom `ASTNode` structures derived from Tree-sitter query matches.

***

## 🌲 CST (Concrete Syntax Tree)

* **Source**: Direct output of Tree-sitter.
* **Structure**: Includes *every* token and punctuation.
* **Generation**: Recursively traverses the Tree-sitter node tree (see `ts_tree_to_cst`).

### 🔧 Uses:

* Precise **source range** and **token alignment**
* **Code formatting** and low-level transformation
* **Reconstruction** of original source code

***

## 🌳 AST (Abstract Syntax Tree, Query-Driven)

* **Source**: Built by executing `.scm` Tree-sitter queries to extract semantic constructs.
* **Managed by**: `QueryManager` (handles caching and loading).
* **Generated by**: `ts_tree_to_ast`.

### 🧠 AST Nodes Represent:

* Functions
* Classes
* Methods
* Control structures
* Variable declarations
  (Extensible via custom `.scm` queries)

### 🔧 Uses:

* High-level code understanding
* InfoBlocks
* Symbol IR
* Call-Graph IR
* Refactoring and semantic tools


Utility: Always keep in mind when attempting to get the structure correct in the unit tests, there exists utility executables `scripts/parse_ast` and `scripts/parse_cst` available

***

## 🧩 Integration Components (2025 Architecture)

* `tree_sitter_integration.c`: Wraps Tree-sitter C API; provides CST/AST extraction.
* `parser.c`: Coordinates parsing process; manages `ParserContext`, memory, and orchestration.
* `query_manager.c`: Loads, compiles, and caches `.scm` query files.
* `parser.h`: Declares:

  * `ASTNode`, `CSTNode`
  * Lifecycle methods: `_new`, `_free`, `_add_child`

***

## 🛠️ How to Extend / Customize

### ➕ Add New Semantic Constructs:

1. Create a new query file, e.g.:

   ```
   queries/python/classes.scm
   ```
2. Update `ts_tree_to_ast` to handle new capture patterns.

### 🌐 Add a New Language:

1. Integrate the Tree-sitter grammar.
2. Add appropriate `.scm` queries.
3. Register the language in:

   * `QueryManager`
   * Parser initialization logic

***

## ⚠️ Important Distinctions

| Feature   | CST                                         | AST                                  |
| --------- | ------------------------------------------- | ------------------------------------ |
| Scope     | Full syntax (lossless)                      | Semantic constructs only             |
| Language  | Language-specific                           | Language-agnostic                    |
| Use Cases | Formatting, reconstruction, low-level tools | Refactoring, analysis, IR generation |
| Structure | Every token preserved                       | High-level constructs only           |
