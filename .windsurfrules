# Most Important Notes

* Do not write "you" or "your" in the code. Write comments with a standard documentation tone. In the comments, note useful information, caveats, and todo/action items. If you see commented code that do not follow this best practice, update them at the spot. Also clarify vague messages whenever possible.

* Build the python bindings with this command ran from the project root directory: `cd core/ && pybind`

* I am going to suggest you to fix errors in the test suite at times. Do not manually execute command strings to run the test suite unless if you are targeting a single test, even though that is not preferred. Run the tests via the shell scripts in the project root directory.

Here are the shell scripts
- run_cpp_tests.sh
- run_c_tests.sh
- run_js_tests.sh
- run_misc_tests.sh <- Tests basic functionality for parsing
- run_python_tests.sh
- run_ts_tests.sh

# ðŸ” Tree-sitter Parsing in ScopeMux

## ðŸ“š Role of Tree-sitter

Tree-sitter provides **incremental**, **multi-language** parsing capabilities.
It outputs **Concrete Syntax Trees (CSTs)** directly from source code and supports semantic extraction via **Tree-sitter queries**.

ScopeMux now supports dual-mode parsing:

* **CSTs**: Full-fidelity syntax trees that include every token, punctuation, and structure.
* **ASTs**: Semantic, language-agnostic trees using custom `ASTNode` structures derived from Tree-sitter query matches.

***

## ðŸŒ² CST (Concrete Syntax Tree)

* **Source**: Direct output of Tree-sitter.
* **Structure**: Includes *every* token and punctuation.
* **Generation**: Recursively traverses the Tree-sitter node tree (see `ts_tree_to_cst`).

### ðŸ”§ Uses:

* Precise **source range** and **token alignment**
* **Code formatting** and low-level transformation
* **Reconstruction** of original source code

***

## ðŸŒ³ AST (Abstract Syntax Tree, Query-Driven)

* **Source**: Built by executing `.scm` Tree-sitter queries to extract semantic constructs.
* **Managed by**: `QueryManager` (handles caching and loading).
* **Generated by**: `ts_tree_to_ast`.

### ðŸ§  AST Nodes Represent:

* Functions
* Classes
* Methods
* Control structures
* Variable declarations
  (Extensible via custom `.scm` queries)

### ðŸ”§ Uses:

* High-level code understanding
* InfoBlocks
* Symbol IR
* Call-Graph IR
* Refactoring and semantic tools

***

## ðŸ§© Integration Components (2025 Architecture)

* `tree_sitter_integration.c`: Wraps Tree-sitter C API; provides CST/AST extraction.
* `parser.c`: Coordinates parsing process; manages `ParserContext`, memory, and orchestration.
* `query_manager.c`: Loads, compiles, and caches `.scm` query files.
* `parser.h`: Declares:

  * `ASTNode`, `CSTNode`
  * Lifecycle methods: `_new`, `_free`, `_add_child`

***

## ðŸ› ï¸ How to Extend / Customize

### âž• Add New Semantic Constructs:

1. Create a new query file, e.g.:

   ```
   queries/python/classes.scm
   ```
2. Update `ts_tree_to_ast` to handle new capture patterns.

### ðŸŒ Add a New Language:

1. Integrate the Tree-sitter grammar.
2. Add appropriate `.scm` queries.
3. Register the language in:

   * `QueryManager`
   * Parser initialization logic

***

## âš ï¸ Important Distinctions

| Feature   | CST                                         | AST                                  |
| --------- | ------------------------------------------- | ------------------------------------ |
| Scope     | Full syntax (lossless)                      | Semantic constructs only             |
| Language  | Language-specific                           | Language-agnostic                    |
| Use Cases | Formatting, reconstruction, low-level tools | Refactoring, analysis, IR generation |
| Structure | Every token preserved                       | High-level constructs only           |
